# A0129708X
###### logic\BinDisplay.java
``` java
package logic;

import java.util.ArrayList;

import org.joda.time.DateTime;

import application.Constants;

public class BinDisplay {
    ArrayList<Task> bufferList;
    ArrayList<Task> displayList;
    BinSorter sorter;

    public BinDisplay() {
	bufferList = new ArrayList<Task>();
	displayList = new ArrayList<Task>();
	sorter = new BinSorter();
    }

    //
    public ArrayList<Task> initDisplay(ArrayList<Task> taskList) {
	bufferList = taskList;
	sorter.sortArrayByTime(bufferList);
	setDisplay(bufferList);
	return bufferList;
    }

    // To display all the tasks today
    public ArrayList<Task> displayToday(ArrayList<Task> taskList) {
	ArrayList<Task> result = new ArrayList<Task>();
	DateTime now = new DateTime();
	DateTime startOfDay = now.withTimeAtStartOfDay();
	DateTime endOfDay = startOfDay.plusHours(24);
	for (Task task : taskList) {
	    switch (task.getType()) {
	    case Constants.TYPE_FLOATING:
		result.add(task);
		break;

	    case Constants.TYPE_EVENT:
		if (task.getEndingTime().isBefore(endOfDay) && (task.getEndingTime().isAfter(startOfDay))) {
		    result.add(task);
		}
		break;

	    case Constants.TYPE_DEADLINE:
		if (task.getEndingTime().isBefore(endOfDay)) {
		    result.add(task);
		}
		break;

	    case Constants.TYPE_RECUR:
		for (DateTime date : task.getRecurDates()) {
		    if (date.getDayOfYear() == now.getDayOfYear()) {
			result.add(task);
		    }
		}
		break;
	    }
	}

	return result;
    }

    // to display all tasks within one week and unfinished tasks
    public void setDisplay(ArrayList<Task> taskList) {
	ArrayList<Task> dis = new ArrayList<Task>();
	for (Task t : taskList) {
	    if (isWithinOneWeek(t) && (!t.getStatus())) {
		dis.add(t);
	    }
	}

	dis = sorter.sortArrayByTime(dis);
	displayList = dis;
    }

    // display all tasks at one specific date
    public ArrayList<Task> setDisplay(ArrayList<Task> taskList, DateTime date) {
	ArrayList<Task> display = new ArrayList<Task>();
	for (Task t : taskList) {
	    if (t.getEndingTime().getDayOfYear() == date.getDayOfYear()) {
		display.add(t);
	    }
	}
	displayList = display;
	return display;
    }

    // return the display list back
    public ArrayList<Task> returnDisplay() {
	displayList = sorter.sortArrayByTime(displayList);
	return displayList;
    }

    // display all tasks in the designated list
    public void setDisplayAll(ArrayList<Task> taskList) {
	displayList = taskList;
    }

    // Check whether the ending date of the task is within one week from now
    public boolean isWithinOneWeek(Task t) {
	DateTime now = new DateTime();
	DateTime weekAfter = now.plusDays(7);
	if (t.getType().equals(Constants.TYPE_RECUR)) {
	    ArrayList<DateTime> dates = t.getRecurDates();
	    for (DateTime date : dates) {
		if (date.isAfter(now) && date.isBefore(weekAfter)) {
		    return true;
		}
	    }
	    return false;
	} else if (t.getType().equals(Constants.TYPE_FLOATING)) {
	    return true;
	} else {
	    if (t.getEndingTime().isAfter(now.plusWeeks(1))) {
		return false;
	    } else {
		return true;
	    }
	}
    }

    // Update the display list after each action is performed
    public void updateDisplay(Command command, boolean todo) {
	if (todo) {
	    switch (command.returnCommand()) {
	    case Constants.alter_tag:
		displayList.remove(command.returnOrigin());
		displayList.add(command.returnMani());
		break;

	    case Constants.mark_tag:
		displayList.get(displayList.indexOf(command.returnMani())).mark();
		break;
	    case Constants.unmark_tag:
		displayList.get(displayList.indexOf(command.returnMani())).unMark();
		break;
	    default:
		System.out.println("Error: Unable to identify the command type");
	    }
	} else {
	    switch (command.returnCommand()) {
	    case Constants.alter_tag:
		if (displayList.contains(command.returnOrigin())) {
		    displayList.add(displayList.get(displayList.indexOf(command.returnOrigin())));
		    displayList.remove(command.returnMani());
		}
		break;

	    case Constants.mark_tag:
		displayList.get(displayList.indexOf(command.returnMani())).unMark();
		break;
	    case Constants.unmark_tag:
		displayList.get(displayList.indexOf(command.returnMani())).mark();
		break;
	    default:
		System.out.println("Error: Unable to identify the command type");
	    }
	}
    }
}
```
###### logic\BinSorter.java
``` java

package logic;

import java.util.ArrayList;

import application.Constants;

public class BinSorter {

    // Check whether the target String array includes all the the keywords
    // stored in the keyword array
    public boolean includeAllWords(String[] keywords, String[] title) {
	boolean isFound;
	for (String key : keywords) {
	    isFound = false;
	    for (String til : title) {
		if (key.equalsIgnoreCase(til)) {
		    isFound = true;
		}
	    }
	    if (isFound == false) {
		return false;
	    }
	}
	return true;
    }

    // Sort the array in seq of time, with normal task at the top, followed by
    // recurring tasks and finally floating task
    public ArrayList<Task> sortArrayByTime(ArrayList<Task> inboxArr) {
	ArrayList<Task> normalTask = new ArrayList<Task>();
	ArrayList<Task> timeUndefined = new ArrayList<Task>();
	ArrayList<Task> recurList = new ArrayList<Task>();
	if (inboxArr.size() <= 1) {
	    return inboxArr;
	}
	for (int m = 0; m < inboxArr.size(); m++) {
	    switch (inboxArr.get(m).getType()) {
	    case Constants.TYPE_RECUR:
		recurList.add(inboxArr.get(m));
		break;
	    case Constants.TYPE_FLOATING:
		timeUndefined.add(inboxArr.get(m));
		break;
	    default:
		normalTask.add(inboxArr.get(m));
	    }
	}
	timeUndefined = sortArrayByAlpha(timeUndefined);
	for (int i = 1; i < normalTask.size() - 1; i++) {
	    boolean isSorted = true;
	    for (int m = 0; m < inboxArr.size() - i - 1; m++) {
		if (normalTask.get(i).getEndingTime().isAfter(normalTask.get(i + 1).getEndingTime())) {
		    Task buffer = normalTask.get(i);
		    normalTask.set(i, normalTask.get(i + 1));
		    normalTask.set(i + 1, buffer);
		    isSorted = false;
		    break;
		}
	    }
	    if (isSorted) {
		break;
	    }
	}

	for (int i = 1; i < recurList.size() - 1; i++) {
	    boolean isSorted = true;
	    for (int m = 1; m < recurList.size() - i; m++) {

		if (recurList.get(i).getEndingTime().getMinuteOfDay() > recurList.get(i + 1).getEndingTime()
			.getMinuteOfDay()) {
		    Task buffer = recurList.get(i);
		    recurList.set(i, recurList.get(i + 1));
		    recurList.set(i + 1, buffer);
		    isSorted = false;
		    break;
		}
	    }
	    if (isSorted) {
		break;
	    }
	}

	inboxArr.clear();
	inboxArr.addAll(normalTask);
	inboxArr.addAll(recurList);
	inboxArr.addAll(timeUndefined);

	return inboxArr;
    }

    // Sort the array in alphabetical sequence
    public ArrayList<Task> sortArrayByAlpha(ArrayList<Task> inboxArr) {
	for (int m = 1; m < inboxArr.size(); m++) {
	    boolean isSorted = true;
	    for (int i = 0; (i < inboxArr.size() - m); i++) {
		boolean isCompared = false;
		for (int j = 0; (j < inboxArr.get(i).getTitle().length() - 1) && (isCompared != true); j++) {
		    if (inboxArr.get(i).getTitle().charAt(j) > inboxArr.get(i + 1).getTitle().charAt(j)) {
			Task buffer = inboxArr.get(i);
			inboxArr.set(i, inboxArr.get(i + 1));
			inboxArr.set(i + 1, buffer);
			isSorted = false;
			isCompared = true;
			break;
		    } else if (inboxArr.get(i).getTitle().charAt(j) < inboxArr.get(i + 1).getTitle().charAt(j)) {
			isCompared = true;
			break;
		    }
		}

	    }
	    if (isSorted == true) {
		return inboxArr;
	    }
	}
	return inboxArr;
    }

}
```
###### logic\Command.java
``` java
package logic;

public class Command {
    String COMMAND;
    Task taskOrigin;
    Task taskManipulation;

    public Command(String com, Task taskAltered) {
	COMMAND = com;
	taskOrigin = null;
	taskManipulation = taskAltered;
    }

    public Command(String com, Task taskAltered, Task origin) {
	COMMAND = com;
	taskOrigin = origin;
	taskManipulation = taskAltered;
    }

    public String returnCommand() {
	return COMMAND;
    }

    public Task returnMani() {
	return taskManipulation;
    }

    public Task returnOrigin() {
	return taskOrigin;
    }
}
```
###### logic\DisplayTasks.java
``` java

package logic;

import java.util.ArrayList;

import org.joda.time.DateTime;

import application.Constants;

public class DisplayTasks {
	ArrayList<Task> bufferList;
	ArrayList<Task> displayList;

	public DisplayTasks() {
		bufferList = new ArrayList<Task>();
		displayList = new ArrayList<Task>();
	}

	public ArrayList<Task> initDisplay(ArrayList<Task> taskList) {
		bufferList = taskList;
		setDisplay(bufferList);
		return bufferList;
	}

	// To display all the tasks today
	public ArrayList<Task> displayToday(ArrayList<Task> taskList) {
		ArrayList<Task> result = new ArrayList<Task>();
		DateTime now = new DateTime();
		DateTime startOfDay = now.withTimeAtStartOfDay();
		DateTime endOfDay = startOfDay.plusHours(24);
		for (Task task : taskList) {
			switch (task.getType()) {
			case Constants.TYPE_FLOATING:
				result.add(task);
				break;

			case Constants.TYPE_EVENT:
				if (task.getEndingTime().isBefore(endOfDay) && (task.getEndingTime().isAfter(startOfDay))) {
					result.add(task);
				}
				break;

			case Constants.TYPE_DEADLINE:
				if (task.getEndingTime().isBefore(endOfDay)) {
					result.add(task);
				}
				break;

			case Constants.TYPE_RECUR:
				for (DateTime date : task.getRecurDates()) {
					if (date.getDayOfYear() == now.getDayOfYear()) {
						result.add(task);
					}
				}
				break;
			}
		}

		return result;
	}

	// to display all tasks within one week and unfinished tasks
	public void setDisplay(ArrayList<Task> taskList) {
		ArrayList<Task> dis = new ArrayList<Task>();
		for (Task t : taskList) {
			if (isWithinOneWeek(t) || (!t.getStatus())) {
				dis.add(t);
			}
		}

		displayList = dis;
	}

	// display all tasks at one specific date
	public ArrayList<Task> setDisplay(ArrayList<Task> taskList, DateTime date) {
		ArrayList<Task> display = new ArrayList<Task>();
		for (Task t : taskList) {
			if (t.getEndingTime().getDayOfYear() == date.getDayOfYear()) {
				display.add(t);
			}
		}
		displayList = display;
		return display;
	}

	// return the display list back
	public ArrayList<Task> returnDisplay() {
		return displayList;
	}

	// display all tasks in the designated list
	public void setDisplayAll(ArrayList<Task> taskList) {
		displayList = taskList;
	}

	// Check whether the ending date of the task is within one week from now
	public boolean isWithinOneWeek(Task t) {
		DateTime now = new DateTime();
		DateTime weekAfter = now.plusDays(7);
		if (t.getType().equals(Constants.TYPE_RECUR)) {
			ArrayList<DateTime> dates = t.getRecurDates();
			for (DateTime date : dates) {
				if (date.isAfter(now) && date.isBefore(weekAfter)) {
					return true;
				}
			}
			return false;
		} else if (t.getType().equals(Constants.TYPE_FLOATING)) {
			return true;
		} else {
			if (t.getEndingTime().isAfter(now.plusWeeks(1))) {
				return false;
			} else {
				return true;
			}
		}
	}

	public void updateDisplay(Command command, boolean todo) {
		if (todo) {
			switch (command.returnCommand()) {
			case Constants.alter_tag:
				displayList.remove(displayList.get(displayList.indexOf(command.returnOrigin())));
				displayList.add(command.returnMani());
				break;

			case Constants.mark_tag:
				displayList.get(displayList.indexOf(command.returnMani())).mark();
				break;
			case Constants.unmark_tag:
				displayList.get(displayList.indexOf(command.returnMani())).unMark();
				break;
			}
		} else {
			switch (command.returnCommand()) {
			case Constants.alter_tag:
				displayList.add(displayList.get(displayList.indexOf(command.returnOrigin())));
				displayList.remove(command.returnMani());
				break;

			case Constants.mark_tag:
				displayList.get(displayList.indexOf(command.returnMani())).unMark();
				break;
			case Constants.unmark_tag:
				displayList.get(displayList.indexOf(command.returnMani())).mark();
				break;
			}
		}
	}
}
```
###### logic\InvalidTimeException.java
``` java
package logic;

public class InvalidTimeException extends Exception {
    /**
    * 
    */
    private static final long serialVersionUID = 1L;

    // Parameterless Constructor
    public InvalidTimeException() {
    }

    // Constructor that accepts a message
    public InvalidTimeException(String message) {
	super(message);
    }
}
```
###### logic\Logic.java
``` java
package logic;

import java.text.ParseException;
import java.util.ArrayList;

import org.joda.time.DateTime;

import application.Constants;
import parser.CommandParser;
import parser.Parser;
import parser.TitleParser;
import storage.Storage;

public class Logic {

    Parser parser = new Parser();
    TaskBin bin = new TaskBin();

    public Logic() {
	bin.init();
    }

    public ArrayList<Task> inputHandler(String input) throws ParseException, InvalidTimeException {
	String command = CommandParser.getCommand(input);

	if (command.equalsIgnoreCase((Constants.COMMAND_ADD))) {
	    return addTask(input);
	} else if (command.equalsIgnoreCase(Constants.COMMAND_VIEW_HOMESCREEN)) {
	    return displayHome();
	} else if (command.equalsIgnoreCase(Constants.COMMAND_SETPATH)) {
	    Storage.setPath(input.split(" ")[1].trim());
	    return displayHome();
	} else if (command.equalsIgnoreCase(Constants.COMMAND_DELETE)) {
	    return deleteTaskByIndex(parser.getIndex(input));
	} else if (command.equals(Constants.COMMAND_EDIT)) {
	    return editTask(parser.getIndex(input), parser.getField(input), TitleParser.getEditTitle(input));
	} else if (command.equals(Constants.COMMAND_MARK)) {
	    return markTaskByIndex(parser.getIndexes(input));
	} else if (command.equals(Constants.COMMAND_UNMARK)) {
	    return unMarkTaskByIndex(parser.getIndexes(input));
	} else if (command.equalsIgnoreCase(Constants.COMMAND_SEARCH)) {
	    ArrayList<Task> result = searchEntries(parser.getTitle(input));
	    return bin.returnDisplay();
	} else if (command.equalsIgnoreCase(Constants.COMMAND_UNDO)) {
	    bin.undo();
	    return bin.returnDisplay();
	} else if (command.equalsIgnoreCase(Constants.COMMAND_REDO)) {
	    bin.redo();
	    return bin.returnDisplay();
	} else if (command.equalsIgnoreCase(Constants.COMMAND_ENQUIREPATH)) {
	    return bin.returnDisplay();
	} else if (command.equalsIgnoreCase(Constants.COMMAND_SHOW)) {

	    if (parser.getTitle(input).equals(Constants.STATUS_INCOMPLETE)) {
		return bin.displayUnfinished();
	    } else if (parser.getTitle(input).equals(Constants.STATUS_COMPLETE)) {
		return bin.displayFinished();
	    }

	    if (parser.getDateTime(input).getYear() == 0) {
		return bin.displayAll();
	    }

	    return searchEntries(parser.getDateTime(input));
	} else if (command.equalsIgnoreCase(Constants.COMMAND_EXIT)) {
	    System.exit(0);
	} else if (command.equalsIgnoreCase(Constants.COMMAND_HELP)) {
	    return displayHome();
	}

	return null;
    }

    public ArrayList<Task> addTask(String input) throws ParseException, InvalidTimeException {

	String title = parser.getTitle(input);
	Task newTask = new Task();
	if (title.length() != 0) {
	    DateTime startTime = parser.getStartDateTime(input);
	    DateTime endTime = parser.getEndDateTime(input);
	    if (!parser.getRecurValue(input).equals("")) {
		String recurValue = parser.getRecurValue(input);
		DateTime endRecur = new DateTime();
		endRecur = endRecur.plusYears(1);
		newTask = new Task(title, startTime, endTime, endRecur, recurValue);
	    } else {
		newTask = new Task(title, startTime, endTime);
	    }

	    bin.add(newTask);
	}
	ArrayList<Task> newList = bin.returnDisplay();
	return newList;
    }

    public ArrayList<Task> displayHome() {

	return bin.displayHome();
    }

    public ArrayList<Task> displayCurrent() {
	return this.bin.returnDisplay();
    }

    public ArrayList<Task> editTask(int index, String field, String info) {
	Task toEdit = bin.returnDisplay().get(index - 1);
	switch (field) {
	case "title":
	    bin.editTitle(toEdit, info);
	    break;
	case "start":
	    if (toEdit.getType().equals(Constants.TYPE_RECUR)) {
		break;
	    }
	    bin.editStartingDate(toEdit, parser.getDateTime(info));
	    break;
	case "end":
	    if (toEdit.getType().equals(Constants.TYPE_RECUR)) {
		break;
	    }
	    bin.editEndingDate(toEdit, parser.getDateTime(info));
	    break;
	case "time":
	    if (toEdit.getType().equals(Constants.TYPE_RECUR)) {
		break;
	    }
	    System.out.println("The new starting time is: " + parser.getStartDateTime(info).toString() + ".  "
		    + "The ending Time is " + parser.getEndDateTime(info).toString() + " . ");
	    bin.editTimeField(toEdit, parser.getStartDateTime(info), parser.getEndDateTime(info));
	    break;
	}
	return bin.returnDisplay();
    }

    public ArrayList<Task> undoChange() {
	bin.undo();
	return bin.returnDisplay();
    }

    public ArrayList<Task> redoChange() {
	bin.redo();
	return bin.returnDisplay();
    }

    public ArrayList<Task> deleteTaskByName(String input) throws ParseException {
	String title = parser.getTitle(input);
	DateTime endingDate = parser.getEndDateTime(input);
	if (endingDate == null) {
	    endingDate = DateTime.now();
	}
	ArrayList<Task> result = bin.findTaskByTitle(title);
	if (result.size() > 1) {
	    result = bin.findTaskByDate(result, endingDate);
	}
	bin.delete(result.get(0));
	return bin.returnDisplay();
    }

    public ArrayList<Task> deleteTaskByIndex(int index) {
	ArrayList<Task> display = bin.returnDisplay();
	Task toDel = new Task();
	toDel = display.get(index - 1);
	bin.delete(toDel);
	return bin.returnDisplay();
    }

    public void showOverdue() {
    }

    public ArrayList<Task> searchEntries(String keyWord) {
	ArrayList<Task> result = bin.findTaskByTitle(keyWord);
	return bin.returnDisplay();
    }

    public ArrayList<Task> searchEntries(DateTime date) {
	ArrayList<Task> result = bin.findTaskByDate(date);
	return bin.returnDisplay();
    }

    public ArrayList<Task> markTaskByIndex(ArrayList<Integer> indexArray) {
	for (int index : indexArray) {
	    ArrayList<Task> display = bin.returnDisplay();
	    Task toMark = new Task();
	    toMark = display.get(index - 1);
	    bin.markTaskInstance(toMark);
	}
	return bin.returnDisplay();
    }

    public ArrayList<Task> unMarkTaskByIndex(ArrayList<Integer> indexArray) {
	for (int index : indexArray) {
	    ArrayList<Task> display = bin.returnDisplay();
	    Task toMark = new Task();
	    toMark = display.get(index - 1);
	    bin.unmarkTaskInstance(toMark);
	}
	return bin.returnDisplay();
    }

    public void changeDirectory() {

    }

    public void editSettings() {

    }

    public void clear() {
	bin.clear();
    }

    public ArrayList<Task> startupDisplay() {// display the initial screen
	ArrayList<Task> initDis = bin.displayHome();
	return initDis;
    }

```
###### logic\Task.java
``` java

package logic;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Level;

import org.joda.time.DateTime;

import application.Constants;
import application.LogHandler;

public class Task {
    private String title;
    private DateTime startingTime;
    private DateTime endingTime;
    private DateTime recurEnd;
    private String type_tag;
    private String recurTag;
    private boolean isRecur;
    private boolean isFinished;
    private ArrayList<DateTime> recurDate;
    private ArrayList<DateTime> recurDone;

    public Task(Task task) {
	this.isRecur = task.isTypeRecur();
	this.recurTag = task.returnRecurTag();
	this.recurEnd = task.getRecurEnd();
	this.title = task.getTitle();
	this.type_tag = task.getType();
	this.isFinished = task.returnIsFinished();
	this.startingTime = task.getStartingTime();
	this.endingTime = task.getEndingTime();
	this.recurDate = task.getRecurDates();
	this.recurDone = task.getDoneDates();

    }

    public Task(String title) {
	this.recurTag = new String();
	this.title = title;
	isFinished = false;
	isRecur = false;
	setTag();
    }

    public Task() {
	this.recurTag = new String();
	String time = Calendar.getInstance().toString();
	isRecur = false;
	this.title = "Untitled " + time;
	this.isFinished = false;

    }

    public Task(String title, DateTime startingTime, DateTime endingTime) throws InvalidTimeException {
	this.title = title;
	this.recurTag = new String();
	this.startingTime = startingTime;
	this.endingTime = endingTime;
	isRecur = false;
	try {
	    if (endingTime.isBefore(startingTime)) {
		InvalidTimeException e = new InvalidTimeException("The ending time is prior to the starting time");
		throw e;
	    }
	} catch (InvalidTimeException e) {
	    String warning = "Error" + e;
	    LogHandler.log(Level.INFO, warning);
	}
	setTag();
    }

    public Task(DateTime startingTime, DateTime endingTime) {

	this();
	this.startingTime = startingTime;
	this.endingTime = endingTime;
	this.recurTag = new String();
	isRecur = false;
	try {
	    if (endingTime.isBefore(startingTime)) {
		InvalidTimeException e = new InvalidTimeException("The ending time is prior to the starting time");
		throw e;
	    }
	} catch (InvalidTimeException e) {
	    String warning = "Error" + e;
	    LogHandler.log(Level.INFO, warning);
	}
	setTag();
    }

    public Task(String title, DateTime endingTime) {
	this(title);
	this.endingTime = endingTime;
	isRecur = false;
	setTag();
    }

    public Task(DateTime date) {
	this();
	this.endingTime = date;
	isRecur = false;
	setTag();
    }

    // Construction method for creating a recurring task
    public Task(String title, DateTime startingTime, DateTime endingTime, DateTime recurEnding, String recurTag) {
	isRecur = true;
	isFinished = false;
	this.recurTag = recurTag;
	this.title = title;
	this.startingTime = startingTime;
	this.endingTime = endingTime;
	this.recurEnd = recurEnding;
	DateTime end = new DateTime(endingTime);
	this.type_tag = Constants.TYPE_RECUR;
	recurDate = new ArrayList<DateTime>();
	recurDone = new ArrayList<DateTime>();
	recurDate.add(end);
	switch (recurTag) {
	case Constants.tag_weekly:
	    while (end.plusWeeks(1).isBefore(recurEnd)) {
		end = new DateTime(end.plusWeeks(1));
		recurDate.add(end);

	    }
	    break;
	case Constants.tag_daily:
	    while (end.plusDays(1).isBefore(recurEnd)) {
		end = new DateTime(end.plusDays(1));
		recurDate.add(end);
	    }
	    break;
	case Constants.tag_monthly:
	    while (end.plusMonths(1).isBefore(recurEnd)) {
		end = new DateTime(end.plusMonths(1));
		recurDate.add(end);
	    }
	    break;
	case Constants.tag_yearly:
	    while (end.plusMonths(1).isBefore(recurEnd)) {
		end = new DateTime(end.plusYears(1));
		recurDate.add(end);
	    }
	    break;
	}
    }

    public String getTitle() {
	return title;
    }

    // Return whether a task is finished,
    // for a recurring task, if the recurring instance for today is finished, it
    // will be marked as finishied
    public boolean getStatus() {
	if (!isTypeRecur()) {
	    return isFinished;
	} else {
	    return this.isDone();
	}
    }

    public String getType() {
	return type_tag;
    }

    public DateTime getStartingTime() {
	return startingTime;
    }

    // Return the ending time of a task
    // If the task is a recurring task, the task would return the upcoming
    // recurring date
    public DateTime getEndingTime() {
	if (!isTypeRecur()) {
	    return endingTime;
	} else {
	    DateTime earliest = new DateTime(9999, 12, 31, 23, 59);
	    for (DateTime date : recurDate) {
		if (!recurDone.contains(date)) {
		    if (earliest.getMillis() - date.getMillis() > 100000) {
			earliest = date;
		    }
		}
	    }
	    if (earliest.getYear() != 9999) {
		return earliest;
	    } else {
		return null;
	    }
	}
    }

    // Check whether the task is overdue
    public boolean isOverDue() {
	if (!isTypeRecur()) {
	    return endingTime.isBeforeNow() && !type_tag.equals(Constants.TYPE_FLOATING) && (!isFinished);
	} else {
	    DateTime now = new DateTime();
	    for (DateTime t : recurDate) {
		if (t.isBefore(now) && !isDone(t)) {
		    return true;
		}
	    }
	}
	return false;

    }

    public void setTitle(String title) {
	this.title = title;
	if (isTypeRecur()) {
	    isRecur = true;
	}
    }

    public DateTime nextRecur() {
	DateTime earliest = new DateTime(9999, 12, 31, 23, 59);
	for (DateTime date : recurDate) {
	    if (!recurDone.contains(date)) {
		if (earliest.getMillis() - date.getMillis() > 100000) {
		    earliest = date;
		}
	    }
	}
	for (DateTime t : recurDone) {
	    System.out.println("The done date: " + t.toString());
	}
	System.out.println("This is the ending date: " + earliest.toString());
	if (earliest.getYear() != 9999) {
	    return earliest;
	} else {
	    return null;
	}
    }

    public void mark() {
	if (!type_tag.equals(Constants.TYPE_RECUR)) {
	    isFinished = true;
	} else {
	    DateTime now = new DateTime();
	    for (DateTime t : recurDate) {
		if (t.getDayOfYear() == now.getDayOfYear()) {
		    recurDone.add(t);
		    return;
		}
	    }
	}
    }

    public void unMark() {
	if (!type_tag.equals(Constants.TYPE_RECUR)) {
	    isFinished = false;
	} else {
	    DateTime now = new DateTime();
	    for (DateTime t : recurDone) {
		if (t.getDayOfYear() == now.getDayOfYear()) {
		    recurDone.remove(t);
		    return;
		}
	    }
	}
    }

    public void setStartingDate(DateTime startingTime) {
	this.startingTime = startingTime;
	setTag();
    }

    public void setEndingDate(DateTime endingTime) {
	this.endingTime = endingTime;
	setTag();
    }

    public void setTag() {
	if (isTypeRecur()) {
	    this.type_tag = Constants.TYPE_RECUR;
	}
	if (isValidDate(endingTime) || isValidDate(startingTime)) {
	    if (isValidDate(startingTime)) {
		this.type_tag = Constants.TYPE_EVENT; // Event Tasks (have start
						      // and end time)
	    } else {
		this.type_tag = Constants.TYPE_DEADLINE; // Deadline Tasks (have
							 // end but no start
							 // time)
	    }
	} else {
	    this.type_tag = Constants.TYPE_FLOATING; // Floating Tasks (no start
						     // and end date/time)
	}
    }

    public boolean isValidDate(DateTime date) {
	if (date.getYear() == 0) {
	    return false;
	}
	return true;
    }

    @Override
    public boolean equals(Object obj) {
	if (obj instanceof Task) {
	    Task task = (Task) obj;
	    if (!task.isTypeRecur()) {
		return (this.getTitle().equals(task.getTitle())) && (this.getEndingTime().isEqual(task.getEndingTime()))
			&& (this.getEndingTime().isEqual(task.getEndingTime()))
			&& (this.getType().equals(task.getType()));
	    } else {
		return (this.getTitle().equals(task.getTitle())) && (this.getStatus() == task.getStatus())
			&& (this.getRecurEnd().equals(task.getRecurEnd()))
			&& (this.returnRecurTag().equals(task.returnRecurTag()));
	    }

	} else {
	    return false;
	}
    }

    // Return the ending date of the recurring task
    public DateTime getRecurEnd() {
	return recurEnd;
    }

    // Check whether the type of the task is a recurring task
    public boolean isTypeRecur() {
	return this.isRecur;
    }

    // Return the list of dates the task is recurring at
    public ArrayList<DateTime> getRecurDates() {
	if (isTypeRecur())
	    return recurDate;
	return null;
    }

    // Return the list of dates the has been finished in
    public ArrayList<DateTime> getDoneDates() {
	if (isTypeRecur())
	    return recurDone;
	return null;
    }

    // Check whether the task is recurring at the day
    public boolean isRecur() {
	if (!isTypeRecur()) {
	    return false;
	}
	DateTime now = new DateTime();
	for (DateTime t : recurDate) {
	    if (t.getDayOfYear() == now.getDayOfYear()) {
		return true;
	    }
	}
	return false;
    }

    public boolean isRecur(DateTime time) {
	if (!isTypeRecur()) {
	    return false;
	}
	for (DateTime t : recurDate) {
	    if (t.getDayOfYear() == time.getDayOfYear()) {
		return true;
	    }
	}
	return false;
    }

    public String returnRecurTag() {
	return recurTag;
    }

    protected boolean isDone() {
	if (!isTypeRecur()) {
	    return false;
	}
	DateTime now = new DateTime();
	for (DateTime t : recurDone) {
	    if ((t.getDayOfYear() == now.getDayOfYear())) {
		return true;
	    }
	}
	return false;
    }

    private boolean isDone(DateTime date) {
	if (!isTypeRecur()) {
	    return false;
	}
	for (DateTime t : recurDone) {
	    if (t.getDayOfYear() == date.getDayOfYear()) {
		return true;
	    }
	}
	return false;
    }

    public boolean returnIsFinished() {
	return isFinished;
    }

    // delete the specific day from the recurring list
    public DateTime deleteRecur(DateTime date) {
	if (!isTypeRecur()) {
	    return null;
	}
	DateTime del = new DateTime(0, 1, 1, 0, 0);
	for (DateTime t : recurDate) {
	    if (t.getDayOfYear() == date.getDayOfYear()) {
		recurDate.remove(t);
		recurDone.remove(t);
		del = t;
	    }
	}
	return del;
    }

    public String toString() {
	String output = new String("Title: " + getTitle() + "\n" + "Status: " + getStatus() + "\n");
	return output;
    }
}
```
###### logic\TaskBin.java
``` java

package logic;

import java.util.ArrayList;
import java.util.Stack;
import java.util.logging.Level;

import org.joda.time.DateTime;

import application.Constants;
import application.LogHandler;
import storage.Storage;

public class TaskBin {
    ArrayList<Task> taskList;
    ArrayList<Task> displayList;
    BinDisplay display = new BinDisplay();
    BinSorter sorter = new BinSorter();
    Storage taskStorage;
    Stack<Command> undoStack;
    Stack<Command> redoStack;

    public TaskBin(ArrayList<Task> taskList) {
	displayList = new ArrayList<Task>();
	undoStack = new Stack<Command>();
	redoStack = new Stack<Command>();
	this.taskList = taskList;
    }

    public TaskBin() {
	displayList = new ArrayList<Task>();
	undoStack = new Stack<Command>();
	redoStack = new Stack<Command>();
	taskList = new ArrayList<Task>();
    }

    /******************************************* initialization *************************************/

    public void init() {
	taskList = Storage.read();
	display.setDisplay(taskList);
	displayList = display.returnDisplay();
    }

    // Return the list that is current in display.
    public ArrayList<Task> returnDisplay() {

	displayList = display.returnDisplay();
	displayList = sorter.sortArrayByTime(displayList);
	return displayList;
    }

    // Set the display as the initial home screen
    public ArrayList<Task> displayHome() {
	display.setDisplay(taskList);
	displayList = display.returnDisplay();
	return displayList;
    }

    // display all the tasks that are not yet finished
    public ArrayList<Task> displayUnfinished() {
	ArrayList<Task> results = new ArrayList<Task>();
	for (Task t : taskList) {
	    if (t.getStatus() == false) {
		results.add(t);
	    }
	}
	display.setDisplayAll(results);
	displayList = display.returnDisplay();
	return results;
    }

    // display all the tasks that are finished
    public ArrayList<Task> displayFinished() {
	ArrayList<Task> results = new ArrayList<Task>();
	for (Task t : taskList) {
	    if ((t.getStatus() == true) && (t.isTypeRecur() == false)) {
		results.add(t);
	    }
	}
	display.setDisplayAll(results);
	displayList = display.returnDisplay();
	return results;
    }

    // display all the tasks that are stored.
    public ArrayList<Task> displayAll() {
	display.setDisplayAll(taskList);
	displayList = display.returnDisplay();
	return displayList;
    }

    // Add a new task, and back to home display
    public void add(Task newTask) {
	Command add = new Command(Constants.add_tag, newTask);
	this.undoStack.push(add);
	this.taskList.add(newTask);
	taskList = sorter.sortArrayByTime(taskList);
	display.setDisplay(taskList);
	displayList = display.returnDisplay();
	Storage.write(taskList);
	redoStack.clear();
    }

    // delete the task and back to home display
    public void delete(Task task) {
	for (int i = 0; i < taskList.size(); i++) {
	    if (taskList.get(i).equals(task)) {
		Command delete = new Command(Constants.delete_tag, taskList.get(i));
		undoStack.push(delete);
		taskList.remove(i);
		Storage.write(taskList);
		display.setDisplay(taskList);
		displayList = display.returnDisplay();
		break;
	    }
	}

	redoStack.clear();
    }

    // Delete the date of the recur task out of its recurring sequence.
    public void delete(Task task, DateTime date) {
	if (!task.getType().equals(Constants.TYPE_RECUR)) {
	    return;
	}
	for (int i = 0; i < taskList.size(); i++) {
	    if (taskList.get(i).equals(task)) {
		taskList.get(i).deleteRecur(date);
	    }
	}
    }

    // Mark the task instance as finished
    // If its a recurring task, mark today as finished.
    public ArrayList<Task> markTaskInstance(Task task) {
	for (Task obj : taskList) {
	    boolean isFoundRecur = false;
	    if (obj.isTypeRecur()) {
		for (DateTime t : obj.getRecurDates()) {
		    if (t.getDayOfYear() == DateTime.now().getDayOfYear()) {
			isFoundRecur = true;
			break;
		    }
		}
		if (!isFoundRecur) {
		    return null;
		}
	    }
	    if (obj.equals(task)) {
		obj.mark();
		Command mark = new Command(Constants.mark_tag, obj);
		undoStack.push(mark);
		display.updateDisplay(mark, true);
	    }
	}
	Storage.write(taskList);
	displayList = display.returnDisplay();
	return displayList;
    }

    // Mark the task instance as unfinished
    // If its a recurring task, mark today as unfinished
    public ArrayList<Task> unmarkTaskInstance(Task task) {
	for (Task obj : taskList) {
	    if (obj.equals(task)) {
		obj.unMark();
		Command unmark = new Command(Constants.unmark_tag, obj);
		undoStack.push(unmark);
		display.updateDisplay(unmark, true);
	    }
	}

	Storage.write(taskList);
	displayList = display.returnDisplay();
	return displayList;

    }

    // Undo the previous user action
    public void undo() {
	if (this.undoStack.isEmpty()) {
	    return;
	}
	Command previousComm = this.undoStack.pop();
	String command = previousComm.returnCommand();
	switch (command) {
	case Constants.add_tag:
	    redoStack.push(previousComm);
	    taskList.remove(previousComm.returnMani());
	    display.setDisplay(taskList);
	    displayList = display.returnDisplay();
	    break;
	case Constants.delete_tag:
	    redoStack.push(previousComm);
	    taskList.add(previousComm.returnMani());
	    display.setDisplay(taskList);
	    displayList = display.returnDisplay();
	    break;
	case Constants.replace_tag:
	    Command add = undoStack.pop();
	    taskList.remove(add.returnMani());
	    redoStack.push(add);
	    Command del = undoStack.pop();
	    taskList.add(del.returnMani());
	    redoStack.push(del);
	    redoStack.push(previousComm);
	    display.setDisplay(taskList);
	    displayList = display.returnDisplay();
	    break;

	case Constants.alter_tag:

	    redoStack.push(previousComm);
	    displayList = display.returnDisplay();
	    taskList.remove(previousComm.returnMani());
	    taskList.add(previousComm.returnOrigin());
	    if (!displayList.equals(taskList)) {
		displayList.remove(displayList.get(displayList.indexOf(previousComm.returnMani())));
		displayList.add(previousComm.returnOrigin());
	    }
	    display.setDisplayAll(displayList);
	    break;

	case Constants.mark_tag:
	    redoStack.push(previousComm);
	    taskList.get(taskList.indexOf(previousComm.returnMani())).unMark();
	    display.updateDisplay(previousComm, false);
	    break;

	case Constants.unmark_tag:
	    redoStack.push(previousComm);
	    taskList.get(taskList.indexOf(previousComm.returnMani())).mark();
	    display.updateDisplay(previousComm, false);
	    break;

	default:
	    LogHandler.log(Level.SEVERE, "Error: Unable to identify the command type");
	}
	Storage.write(taskList);
    }

    // Redo the previous undo action
    public void redo() {
	if (this.redoStack.isEmpty()) {
	    return;
	}
	Command redoComm = redoStack.pop();
	String command = redoComm.returnCommand();
	switch (command) {
	case Constants.add_tag:
	    undoStack.push(redoComm);
	    taskList.add(redoComm.returnMani());
	    display.setDisplay(taskList);
	    displayList = display.returnDisplay();
	    break;
	case Constants.delete_tag:
	    undoStack.push(redoComm);
	    taskList.remove(redoComm.returnMani());
	    display.setDisplay(taskList);
	    displayList = display.returnDisplay();
	    break;
	case Constants.alter_tag:
	    displayList = display.returnDisplay();
	    undoStack.push(redoComm);
	    taskList.remove(taskList.get(taskList.indexOf(redoComm.returnOrigin())));
	    taskList.add(redoComm.returnMani());

	    if (!displayList.equals(taskList)) {
		displayList.remove(displayList.get(displayList.indexOf(redoComm.returnOrigin())));
		displayList.add(redoComm.returnMani());

	    }
	    display.setDisplayAll(displayList);
	    break;

	case Constants.mark_tag:
	    undoStack.push(redoComm);
	    taskList.get(taskList.indexOf(redoComm.returnMani())).mark();
	    display.updateDisplay(redoComm, true);
	    displayList = display.returnDisplay();
	    break;

	case Constants.unmark_tag:
	    undoStack.push(redoComm);
	    taskList.get(taskList.indexOf(redoComm.returnMani())).unMark();
	    display.updateDisplay(redoComm, true);
	    displayList = display.returnDisplay();
	    break;

	default:
	    LogHandler.log(Level.SEVERE, "Error: Unable to identify the command type");

	}

    }

    // Retrieve the tasks with its title includes the keyword in the designated
    // list of task
    public ArrayList<Task> findTaskByTitle(ArrayList<Task> list, String title) {
	ArrayList<Task> result = new ArrayList<Task>();
	String[] keywords = title.split(" ");
	for (Task task : list) {
	    String[] listOfWord = task.getTitle().split(" ");
	    if (sorter.includeAllWords(keywords, listOfWord)) {
		result.add(task);
	    }
	}
	sorter.sortArrayByTime(result);
	display.setDisplayAll(result);
	return result;
    }

    // Retrieve the tasks with its title includes the keyword in the task list
    public ArrayList<Task> findTaskByTitle(String title) {
	ArrayList<Task> result = new ArrayList<Task>();
	String[] keywords = title.split(" ");
	for (Task task : taskList) {
	    String[] listOfWord = task.getTitle().split(" ");
	    if (sorter.includeAllWords(keywords, listOfWord)) {
		result.add(task);
	    }
	}
	sorter.sortArrayByTime(result);
	display.setDisplayAll(result);
	return result;

    }

    // Retrieve the task with the specified date in the list
    public ArrayList<Task> findTaskByDate(ArrayList<Task> list, DateTime date) {
	ArrayList<Task> result = new ArrayList<Task>();
	for (Task task : list) {
	    if (task.getType().equals(Constants.TYPE_RECUR)) {
		for (DateTime t : task.getRecurDates()) {
		    if (t.getDayOfYear() == date.getDayOfYear()) {
			result.add(task);
		    }
		}
	    } else if (!task.getType().equals(Constants.TYPE_FLOATING)) {
		if (date.getDayOfYear() == task.getEndingTime().getDayOfYear()) {
		    result.add(task);
		}
	    }
	}
	sorter.sortArrayByTime(result);
	display.setDisplayAll(result);
	return result;
    }

    // Retrieve the task with the specific date in the task list
    public ArrayList<Task> findTaskByDate(DateTime date) {
	ArrayList<Task> result = new ArrayList<Task>();
	for (Task task : taskList) {
	    if (task.getType().equals(Constants.TYPE_RECUR)) {
		for (DateTime t : task.getRecurDates()) {
		    if (t.getDayOfYear() == date.getDayOfYear()) {
			result.add(task);
		    }
		}
	    } else if (!task.getType().equals(Constants.TYPE_FLOATING)) {
		if (date.getDayOfYear() == task.getEndingTime().getDayOfYear()) {
		    result.add(task);
		}
	    }
	}
	sorter.sortArrayByTime(result);
	display.setDisplayAll(result);
	return result;
    }

    // edit the title of the specified task
    public void editTitle(Task task, String newTitle) {

	Task buffer = new Task(task);
	Task tar = new Task(taskList.get(taskList.indexOf(task)));
	Task tarDis = new Task(displayList.get(displayList.indexOf(tar)));
	taskList.remove(taskList.get(taskList.indexOf(task)));
	displayList.remove(displayList.get(displayList.indexOf(task)));
	tarDis.setTitle(newTitle);
	tar.setTitle(newTitle);
	taskList.add(tar);
	displayList.add(tarDis);
	Command editTil = new Command(Constants.alter_tag, tar, buffer);
	display.setDisplayAll(displayList);
	undoStack.push(editTil);
	Storage.write(taskList);
	redoStack.clear();
    }

    // Edit the time field of task, editing both starting time and ending time
    public void editTimeField(Task task, DateTime startDate, DateTime endDate) {
	if (task.getType().equals(Constants.recur_tag)) {
	    return;
	}
	if (startDate.getYear() == 0) {
	    startDate = task.getStartingTime();
	}
	if (endDate.getYear() == 0) {
	    endDate = task.getEndingTime();
	}
	Task buffer = new Task(task);
	Task tar = new Task(taskList.get(taskList.indexOf(task)));
	Task tarDis = new Task(displayList.get(displayList.indexOf(tar)));
	taskList.remove(taskList.get(taskList.indexOf(task)));
	displayList.remove(displayList.get(displayList.indexOf(task)));
	tar.setStartingDate(startDate);
	tarDis.setStartingDate(startDate);
	tar.setEndingDate(endDate);
	tarDis.setEndingDate(endDate);
	taskList.add(tar);
	displayList.add(tarDis);
	Command editDate = new Command(Constants.alter_tag, tar, buffer);
	undoStack.push(editDate);
	taskList = sorter.sortArrayByTime(taskList);
	display.setDisplayAll(displayList);
	Storage.write(taskList);
	redoStack.clear();
    }

    // Edit the start date of the task to a new date
    public void editStartingDate(Task task, DateTime date) {
	if (task.getType().equals(Constants.recur_tag)) {
	    return;
	}

	Task buffer = new Task(task);
	Task tar = new Task(taskList.get(taskList.indexOf(task)));
	Task tarDis = new Task(displayList.get(displayList.indexOf(tar)));
	taskList.remove(taskList.get(taskList.indexOf(task)));
	displayList.remove(displayList.get(displayList.indexOf(task)));
	tar.setStartingDate(date);
	tarDis.setStartingDate(date);
	taskList.add(tar);
	displayList.add(tarDis);
	Command editDate = new Command(Constants.alter_tag, tar, buffer);
	display.setDisplayAll(displayList);
	undoStack.push(editDate);
	taskList = sorter.sortArrayByTime(taskList);
	Storage.write(taskList);
	redoStack.clear();
    }

    public void editEndingDate(Task task, DateTime date) {
	if (task.getType().equals(Constants.recur_tag)) {
	    return;
	}
	Task buffer = new Task(task);
	Task tar = new Task(taskList.get(taskList.indexOf(task)));
	Task tarDis = new Task(displayList.get(displayList.indexOf(tar)));
	taskList.remove(taskList.get(taskList.indexOf(task)));
	displayList.remove(displayList.get(displayList.indexOf(task)));
	tar.setEndingDate(date);
	tarDis.setEndingDate(date);
	taskList.add(tar);
	displayList.add(tarDis);
	Command editDate = new Command(Constants.alter_tag, tar, buffer);
	display.setDisplayAll(displayList);
	undoStack.push(editDate);
	taskList = sorter.sortArrayByTime(taskList);

	Storage.write(taskList);
	redoStack.clear();
    }

    // Return all the tasks that are overdue
    public ArrayList<Task> returnOverdue() {
	ArrayList<Task> overdue = new ArrayList<Task>();
	DateTime now = DateTime.now();
	ArrayList<Task> undone = getUnfinished();
	for (Task t : undone) {
	    if ((t.getEndingTime().isAfter(now)) && (!t.getType().equals(Constants.TYPE_FLOATING))) {
		overdue.add(t);
	    }
	}
	return overdue;

    }

    // Return all the unfinished tasks
    public ArrayList<Task> getUnfinished() {
	ArrayList<Task> result = new ArrayList<Task>();
	for (Task task : taskList) {
	    if (task.isDone() == false) {
		result.add(task);
	    }
	}
	return result;
    }

    // Check whether the period of time has clashed with time of existing tasks
    // in the tasklist
    public boolean isClashed(DateTime[] time) {
	DateTime start = time[0];
	DateTime end = time[1];
	for (Task t : taskList) {
	    if ((t.getType().equals(Constants.TYPE_FLOATING)) || (t.getType().equals(Constants.TYPE_RECUR))) {
		continue;
	    }
	    if ((t.getStartingTime().getSecondOfDay() == start.getSecondOfDay())
		    && (t.getEndingTime().getSecondOfDay() == end.getSecondOfDay())) {
		continue;
	    }
	    if ((t.getStartingTime().isBefore(end)) && (t.getStartingTime().isAfter(start))) {
		return true;
	    }
	    if ((t.getEndingTime().isAfter(start)) && (t.getEndingTime().isBefore(end))) {
		return true;
	    }
	}
	return false;
    }

    // Return all the tasks that are inbox
    public ArrayList<Task> returnAllInbox() {
	return new ArrayList<Task>(taskList);
    }

    // Clear all tasks in the taskBin and storage
    public void clear() {
	taskList.clear();
	Storage.write(taskList);
    }

}
```
###### test\LogicTest.java
``` java
package test;

import static org.junit.Assert.assertTrue;

import java.text.ParseException;
import java.util.ArrayList;

import org.junit.Test;

import logic.InvalidTimeException;
import logic.Logic;
import logic.Task;

public class LogicTest {

    private static String[] command1 = { "add have dinner with James from 1200 to 1300", "add buy flower for Sherry",
	    "add write report by 10/11", "add hand in CS2013 report by tmr",
	    "add CS2103 tutorial from 1000 to 1100 weekly", "add take MRT to Jurong by 1800", "mark 1", "del 2" };
    private static String[] command2 = { "edit 1 time from 1200 tmr to 1300 tmr", "show tmr", "m 1", "undo" };

    @Test
    public void testInputHandler() throws ParseException, InvalidTimeException {
	Logic testLogic = new Logic();
	testLogic.clear();
	ArrayList<Task> output = new ArrayList<Task>();
	String outputString, refString;
	for (String s : command1) {
	    output = testLogic.inputHandler(s);
	}
	outputString = output.toString();
	refString = new String(
		"[Title: hand in CS2013 report\nStatus: false\n, Title: take MRT to Jurong\nStatus: false\n, Title: CS2103 tutorial\nStatus: false\n, Title: buy flower for Sherry\nStatus: false\n]");
	System.out.println(refString);
	System.out.println(outputString);
	assertTrue(refString.equals(outputString));
	for (String s : command2) {
	    output = testLogic.inputHandler(s);
	}
	outputString = output.toString();
	refString = new String("[Title: hand in CS2013 report\nStatus: false\n]");
	System.out.println(refString);
	System.out.println(outputString);
	assertTrue(refString.equals(outputString));
    }

}
```
###### test\SorterTest.java
``` java
package test;

import static org.junit.Assert.assertTrue;

import java.util.ArrayList;

import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;

import application.Constants;
import logic.BinSorter;
import logic.InvalidTimeException;
import logic.Task;
import logic.TaskBin;

public class SorterTest {
    static DateTime invalid = new DateTime(0, 1, 1, 0, 0);
    static DateTime date1 = new DateTime(2015, 11, 12, 0, 0);
    static DateTime date1_2 = new DateTime(2015, 11, 12, 22, 21);
    static DateTime date2 = new DateTime(2016, 1, 15, 0, 1);
    static DateTime date3 = new DateTime(2015, 12, 11, 0, 0);
    static DateTime date4 = new DateTime(2015, 11, 15, 0, 0);
    static DateTime date5 = new DateTime(2016, 10, 20, 0, 0);
    static BinSorter sorter = new BinSorter();

    @Before
    public void setUp() throws Exception {

    }

    @Test
    public void testSortArrayByTime() throws InvalidTimeException {
	boolean equals = true;
	Task[] taskArr = new Task[8];
	taskArr[0] = new Task("Floating task 1", new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));// U,0
	taskArr[1] = new Task("task that recurs", date1, date1_2, date5, Constants.tag_weekly);
	// R
	taskArr[2] = new Task("A task for the past", new DateTime(1994, 1, 1, 0, 0), new DateTime(2001, 1, 1, 0, 0));
	// P

	taskArr[3] = new Task("多语言支持", new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	// 0
	taskArr[4] = new Task("zstarts and end at different year", new DateTime(2015, 11, 12, 0, 0),
		new DateTime(2016, 1, 15, 0, 1));
	// 16
	taskArr[5] = new Task("Task ends before it starts", new DateTime(2015, 12, 11, 0, 0),
		new DateTime(2015, 11, 15, 0, 0));
	// 15
	taskArr[6] = new Task("Zoo", invalid, invalid);
	taskArr[7] = new Task("task for future", new DateTime(2222, 12, 11, 12, 0), new DateTime(3222, 12, 11, 12, 1));
	// taskArr[8] = new
	TaskBin testBin = new TaskBin();
	testBin.add(taskArr[0]);
	testBin.add(taskArr[1]);
	testBin.add(taskArr[2]);
	testBin.add(taskArr[3]);
	testBin.add(taskArr[4]);
	testBin.add(taskArr[5]);
	testBin.add(taskArr[6]);
	testBin.add(taskArr[7]);

	ArrayList<Task> expected = new ArrayList<Task>();
	expected.add(taskArr[2]);
	expected.add(taskArr[5]);
	expected.add(taskArr[4]);
	expected.add(taskArr[7]);
	expected.add(taskArr[1]);
	expected.add(taskArr[0]);
	expected.add(taskArr[6]);
	expected.add(taskArr[3]);

	ArrayList<Task> output = sorter.sortArrayByTime(testBin.returnAllInbox());
	for (int i = 0; i < 6; i++) {
	    if (!output.get(i).equals(expected.get(i))) {
		equals = false;
	    }
	}
	assertTrue(equals);

    }

    @Test
    public void testSortArrayByAlpha() throws InvalidTimeException {
	Task task1 = new Task(new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task2 = new Task(
		"The title of the task is super super super super super super super super super super super super super super super super long",
		new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task3 = new Task("多语言支持", new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task4 = new Task("123LetsGO", new DateTime(2015, 11, 12, 0, 0), new DateTime(2016, 1, 15, 0, 1));
	Task task5 = new Task("#$%%^&*(", new DateTime(2015, 12, 11, 0, 0), new DateTime(2015, 11, 15, 0, 0));
	ArrayList<Task> output = new ArrayList<Task>();
	ArrayList<Task> expected = new ArrayList<Task>();
	output.add(task5);
	output.add(task4);
	output.add(task3);
	output.add(task2);
	output.add(task1);
	output = sorter.sortArrayByAlpha(output);
	expected.add(task5);
	expected.add(task4);
	expected.add(task2);
	expected.add(task1);
	expected.add(task3);
	assertTrue(expected.equals(output));

    }

}
```
###### test\TaskBinTest.java
``` java
package test;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;

import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;

import application.Constants;
import logic.InvalidTimeException;
import logic.Task;
import logic.TaskBin;

public class TaskBinTest {
    static DateTime invalid = new DateTime(0, 1, 1, 0, 0);
    static DateTime date1 = new DateTime(2015, 11, 12, 0, 0);
    static DateTime date1_2 = new DateTime(2015, 11, 12, 0, 1);
    static DateTime date2 = new DateTime(2016, 1, 15, 0, 1);
    static DateTime date2_2 = new DateTime(2016, 1, 15, 0, 1);
    static DateTime date3 = new DateTime(1, 12, 11, 0, 0);
    static DateTime date4 = new DateTime(2015, 11, 15, 0, 0);
    static DateTime date5 = new DateTime(9999, 10, 20, 0, 0);
    static DateTime date6 = new DateTime(-1, 10, 20, 0, 0);
    static DateTime date7 = new DateTime(12580, 10, 20, 0, 0);

    @Before
    public void setUp() throws Exception {
    }

    @Test
    public void testAdd() throws InvalidTimeException {
	boolean success = true;
	Task task1 = new Task(new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task2 = new Task(
		"The title of the task is super super super super super super super super super super super super super super super super long",
		new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task3 = new Task("锟斤拷锟斤拷锟斤拷支锟斤拷", new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task4 = new Task("Task starts and end at different year", new DateTime(2015, 11, 12, 0, 0),
		new DateTime(2016, 1, 15, 0, 1));
	Task task5 = new Task("Task ends before it starts", new DateTime(2015, 12, 11, 0, 0),
		new DateTime(2015, 11, 15, 0, 0));
	TaskBin testBin = new TaskBin();
	testBin.add(task1);
	testBin.add(task2);
	testBin.add(task3);
	testBin.add(task4);
	testBin.add(task5);
	ArrayList<Task> output1 = new ArrayList<Task>();
	output1.add(task3);
	output1.add(task2);
	output1.add(task1);
	output1.add(task5);
	output1.add(task4);

	for (int i = 0; i < 5; i++) {
	    System.out.println(testBin.returnAllInbox().get(i).getTitle());
	    for (int j = 0; j < 5; j++) {
		if (output1.get(i).equals(testBin.returnAllInbox().get(j))) {
		    success = true;
		    break;
		} else {
		    success = false;
		}
	    }
	}
    }

    @Test
    public void testDeleteTask() throws InvalidTimeException {
	boolean success = true;
	Task task1 = new Task(new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task2 = new Task(
		"The title of the task is super super super super super super super super super super super super super super super super long",
		new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task3 = new Task("多语言支持", new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task4 = new Task("Task starts and end at different year", new DateTime(2015, 11, 12, 0, 0),
		new DateTime(2016, 1, 15, 0, 1));
	Task task5 = new Task("Task ends before it starts", new DateTime(2015, 12, 11, 0, 0),
		new DateTime(2015, 11, 15, 0, 0));
	TaskBin testBin = new TaskBin();
	testBin.add(task1);
	testBin.add(task2);
	testBin.add(task3);
	testBin.add(task4);
	testBin.add(task5);
	testBin.delete(task1);
	testBin.delete(task3);
	ArrayList<Task> output1 = new ArrayList<Task>();
	output1.add(task4);
	output1.add(task2);
	output1.add(task5);

	for (int i = 0; i < 3; i++) {
	    for (int j = 0; j < 5; j++) {
		if (output1.get(i).equals(testBin.returnAllInbox().get(j))) {
		    success = true;
		    break;
		} else {
		    success = false;
		}
	    }
	}
	assertTrue(success);
    }

    @Test
    public void testMarkTaskInstance() throws InvalidTimeException {
	Task task1 = new Task(new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task2 = new Task(
		"The title of the task is super super super super super super super super super super super super super super super super long",
		new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task3 = new Task("多语言支持", new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task4 = new Task("Task starts and end at different year", new DateTime(2015, 11, 12, 0, 0),
		new DateTime(2016, 1, 15, 0, 1));
	Task task5 = new Task("Task ends before it starts", new DateTime(2015, 12, 11, 0, 0),
		new DateTime(2015, 11, 15, 0, 0));
	TaskBin testBin = new TaskBin();
	testBin.add(task1);
	testBin.add(task2);
	testBin.add(task3);
	testBin.add(task4);
	testBin.add(task5);
	testBin.markTaskInstance(task2);
	testBin.markTaskInstance(task5);
	testBin.markTaskInstance(task3);
	testBin.markTaskInstance(task1);
	ArrayList<Task> result = new ArrayList<Task>();
	for (Task t : testBin.returnAllInbox()) {
	    if (t.getStatus()) {
		result.add(t);
	    }
	}
	assertTrue((result.size() == 4));
    }

    @Test
    public void testUnmarkTaskInstance() throws InvalidTimeException {
	Task task1 = new Task(new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task2 = new Task(
		"The title of the task is super super super super super super super super super super super super super super super super long",
		new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task3 = new Task("多语言支持", new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	Task task5 = new Task("Task ends before it starts", new DateTime(2015, 12, 11, 0, 0),
		new DateTime(2015, 11, 15, 0, 0));
	TaskBin testBin = new TaskBin();
	testBin.add(task1);
	testBin.add(task2);
	testBin.add(task3);
	testBin.add(task5);
	testBin.markTaskInstance(task2);
	testBin.markTaskInstance(task5);
	testBin.markTaskInstance(task3);
	testBin.markTaskInstance(task1);
	testBin.unmarkTaskInstance(task5);
	testBin.unmarkTaskInstance(task1);
	ArrayList<Task> result = new ArrayList<Task>();
	for (Task t : testBin.returnAllInbox()) {
	    if (t.getStatus()) {
		result.add(t);
	    }
	}
	assertTrue(result.size() == 2);
    }

    @Test
    public void testEditTitle() throws InvalidTimeException {
	Task[] task = new Task[5];
	task[0] = new Task(new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	task[1] = new Task(
		"The title of the task is super super super super super super super super super super super super super super super super long",
		new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	task[2] = new Task("多语言支持", new DateTime(0, 1, 1, 0, 0), new DateTime(0, 1, 1, 0, 0));
	task[3] = new Task("Recurring task", new DateTime(2015, 11, 10, 0, 0), new DateTime(2015, 11, 10, 0, 20),
		new DateTime(2016, 5, 10, 0, 20), Constants.tag_weekly);
	task[4] = new Task("Task ends before it starts", new DateTime(2015, 12, 11, 0, 0),
		new DateTime(2015, 11, 15, 0, 0));
	TaskBin testBin = new TaskBin();
	testBin.add(task[0]);
	testBin.add(task[1]);
	testBin.add(task[2]);
	testBin.add(task[3]);
	testBin.add(task[4]);
	for (int i = 0; i < 5; i++) {
	    String newTil = new Integer(i).toString();
	    testBin.editTitle(task[i], newTil);
	}
	String output = new String();
	for (int i = 0; i < 5; i++) {
	    output = output + testBin.returnAllInbox().get(i).getTitle();
	}
	assertEquals(output, "01234");
    }

    @Test
    public void testIsClashedDateTimeArray() throws InvalidTimeException {
	TaskBin testBin = new TaskBin();
	DateTime[] dateArr = { date1, date4 };
	Task[] task = new Task[5];
	task[1] = new Task(date1, date1_2);
	task[2] = new Task(date2, date2_2);
	task[3] = new Task(date3, date4);
	task[4] = new Task(date6, date2);
	task[0] = new Task(date6, date7);
	testBin.add(task[1]);
	testBin.add(task[2]);
	testBin.add(task[3]);
	testBin.add(task[4]);
	testBin.add(task[0]);
	boolean[] result1 = { testBin.isClashed(dateArr), testBin.isClashed(dateArr), testBin.isClashed(dateArr),
		testBin.isClashed(dateArr), testBin.isClashed(dateArr) };
	boolean[] expected = { true, true, true, true, true };
	assertArrayEquals(result1, expected);
    }
}
```
